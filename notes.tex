\documentclass{article}
\usepackage{amsfonts}

\begin{document}
    \begin{titlepage}
        \vspace*{250pt}
        \begin{center}
            {\Huge{CLRS Excersises}}\\[10pt]
            {\Large{by Alex Towle}}\\[8pt]
            {\Large{March 5, 2020}}
        \end{center}
        \vfill
    \end{titlepage}
    \section{The Role of Algorithms in Computing}
        \subsection{Algorithms Excersises}
            \subsubsection{Question} 
                Give a real-world example that requires sorting or a real-world example that requires computing a convex hull.

            \subsubsection{Answer}
                Sorting: Records may need to be sorted by key to be printed out in a human readable form.

                Sorting: We sort orders by OrderHash in Mesh, which allows us to search more effiently for orders.

                Convex Hull: Finding the smallest amount of material that will be required to surround a watch's gears.

        \subsection{1.1.2}
            \subsubsection{Question}
                Other than speed, what other measures of efficiency might one use in a real-world setting?

            \subsubsection{Answer}
                On the Mesh team, we track several metrics including bandwidth usage (both up and down), disk I/O usage,
                CPU usage (this is fairly time based), power consumption, any memory usage.

                The protocol team is concerned amount how cheap they can make transactions on Ethereum, which is not directly
                related to the runtime of the miner's CPUs (this is a bit of an issue).

        \subsection{1.1.3}
            \subsubsection{Question}
                Select a data structure that you have seen previously, and discuss its strengths and limitations.

            \subsubsection{Answer}
                Bloom filters are an interesting data structure. They are used in the Ethereum blockchain to store events
                that have been emitted by smart contract. Specifically, the \"logs bloom\" of an Ethereum block-header is
                a 2048 bit bloom filter that sets three bits per entry. This data-structure is good for performing set existence
                queries in situations where the answer does not always need to be correct and a reasonable false positive rate
                is acceptable. These data structures do not perform well when the number of elements of the set cannot be
                bounded and increases unpredictably. They will fill up, causing bugs if they are relied upon as more than
                a suggestion.
        \subsection{1.1.4}
            \subsubsection{Question}
                How are the shortest-path and traveling-salesman problems given above similar? How are they different?

            \subsubsection{Answer}
                These problems are similar in that they are both trying to find a minimum length path on a graph. At first
                glance this can almost make them sound the same. Another similarity is that there may be a lot of paths that
                must be considered.

                Several differences come to mind between these problems. The traveling-salesman problem is exhaustive by nature.
                The salesperson must go to all of the different destinations, and he is trying to find the shortest path required
                to accomplish this. In contrast, the shortest path problem only requires that the path touch two nodes: the start
                and the finish. This means that if our path has cycles in it, these can be safely removed. The salesman does not
                necessarily have this luck because there are some cycles that will be the shortest way between a cluster of cities
                far away from other cities.
        \subsection{1.1.5}
            \subsubsection{Question}
                Come up with a real-world problem in which only the best solution will do. Then
                come up with one in which a solution that is “approximately” the best is good
                enough.

            \subsubsection{Answer}
                Algorithmic trading is a brutal competition where the fast can steal profits from the slow. This means that even
                small differences in implementations can result in dramatic differences in realized profits (or losses). Differences 
                in the underlying algorithms will ultimately affect the balance-sheets of the companies, for better or for worse.

                Scripts are programs that are typically used to automate a repetitive task. Oftentimes, these scripts automate a set
                of tasks that only needs to be completed once and is not especially time-sensitive. An example of this would be a
                network enumeration script that runs on home networks. The amount of time required to improve the run-time of the script
                will almost certainly fail to be worth the time savings.
\end{document}
